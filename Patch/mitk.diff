diff --git a/CMakeLists.txt b/CMakeLists.txt
index e5bcff7d8b..ef79a9bdba 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -789,6 +789,7 @@ if(NOT MSVC_VERSION)
     -Wno-error=unknown-pragmas
     # The strict-overflow warning is generated by ITK template code
     -Wno-error=strict-overflow
+    -Wno-error=nonnull
     -Woverloaded-virtual
     -Wstrict-null-sentinel
     #-Wold-style-cast
diff --git a/Modules/Annotation/include/mitkColorBarAnnotation.h b/Modules/Annotation/include/mitkColorBarAnnotation.h
index d70f925819..5244f629c2 100644
--- a/Modules/Annotation/include/mitkColorBarAnnotation.h
+++ b/Modules/Annotation/include/mitkColorBarAnnotation.h
@@ -46,7 +46,7 @@ namespace mitk
     itkFactorylessNewMacro(Self);
     itkCloneMacro(Self);
 
-      void SetDrawAnnotations(bool annotations);
+    void SetDrawAnnotations(bool annotations);
     bool GetDrawAnnotations() const;
 
     void SetOrientationToHorizontal();
@@ -69,6 +69,14 @@ namespace mitk
     void SetAnnotationTextScaling(bool scale);
     bool GetAnnotationTextScaling() const;
 
+    void SetFontSize(int s);
+    int GetFontSize() const;
+
+    int GetWidth() const;
+    void SetWidth(int s);
+
+    void SetLength(int s);
+    int GetLenght() const;
   protected:
     /** \brief The LocalStorageHandler holds all LocalStorages for the render windows. */
     mutable mitk::LocalStorageHandler<LocalStorage> m_LSH;
@@ -79,6 +87,8 @@ namespace mitk
     /** \brief explicit constructor which disallows implicit conversions */
     explicit ColorBarAnnotation();
 
+    void Update(mitk::BaseRenderer *renderer) override;
+
     /** \brief virtual destructor in order to derive from this class */
     ~ColorBarAnnotation() override;
 
diff --git a/Modules/Annotation/src/mitkColorBarAnnotation.cpp b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
index 31ee59f04b..40e9aa33da 100644
--- a/Modules/Annotation/src/mitkColorBarAnnotation.cpp
+++ b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
@@ -14,19 +14,24 @@ found in the LICENSE file.
 #include "mitkLookupTable.h"
 #include "mitkLookupTableProperty.h"
 #include <vtkScalarBarActor.h>
+#include <vtkTextProperty.h>
+#include <vtkProperty2D.h>
 
 mitk::ColorBarAnnotation::ColorBarAnnotation()
 {
   SetDrawAnnotations(true);
-
   SetDrawTickLabels(true);
 
   SetOrientationToVertical();
-
   SetMaxNumberOfColors(100);
   SetNumberOfLabels(4);
 
   SetAnnotationTextScaling(false);
+  SetFontSize(8);
+  SetLength(200);
+
+  SetWidth(50);
+  SetColor(0.0, 0.0, 0.0);
 
   SetLookupTable(nullptr);
 }
@@ -42,13 +47,61 @@ mitk::ColorBarAnnotation::~ColorBarAnnotation()
   }
 }
 
-mitk::ColorBarAnnotation::LocalStorage::~LocalStorage()
+mitk::ColorBarAnnotation::LocalStorage::~LocalStorage() {}
+
+void mitk::ColorBarAnnotation::SetFontSize(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Fontsize", s);
+}
+
+int mitk::ColorBarAnnotation::GetFontSize() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Fontsize", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetWidth(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Width", s);
+}
+
+int mitk::ColorBarAnnotation::GetWidth() const
 {
+  int val;
+  GetIntProperty("ColorBarAnnotation.Width", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetLength(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Length", s);
+}
+
+int mitk::ColorBarAnnotation::GetLenght() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Length", val);
+  return val;
 }
 
 mitk::ColorBarAnnotation::LocalStorage::LocalStorage()
 {
   m_ScalarBarActor = vtkSmartPointer<vtkScalarBarActor>::New();
+  m_ScalarBarActor->SetUnconstrainedFontSize(true);
+  m_ScalarBarActor->GetLabelTextProperty()->SetItalic(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetShadow(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBold(0);
+  double v[3] = {1.0, 1.0, 1.0};
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundColor(v);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundOpacity(1);
+  m_ScalarBarActor->SetNumberOfLabels(0);
+  // m_ScalarBarActor->SetNumberOf
+}
+
+void mitk::ColorBarAnnotation::Update(mitk::BaseRenderer *renderer)
+{
+  mitk::VtkAnnotation::Update(renderer);
 }
 
 void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
@@ -64,18 +117,32 @@ void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
     ls->m_ScalarBarActor->SetMaximumNumberOfColors(this->GetMaxNumberOfColors());
     ls->m_ScalarBarActor->SetNumberOfLabels(this->GetNumberOfLabels());
     ls->m_ScalarBarActor->SetAnnotationTextScaling(this->GetAnnotationTextScaling());
+
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetFontSize(this->GetFontSize());
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetFontSize(this->GetFontSize());
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetFontSize(this->GetFontSize());
+
+    float color[3];
+    double colord[3];
+    this->GetColor(color);
+    std::copy(color, color + 3, colord);
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetColor(colord);
+
     // manually set position so there is no overlap with mitk logo in 3d renderwindow
+    auto size = renderer->GetViewportSize();
     if (this->GetOrientation() == 1)
     {
-      ls->m_ScalarBarActor->SetPosition(0.80, 0.15);
-      ls->m_ScalarBarActor->SetWidth(0.15);
-      ls->m_ScalarBarActor->SetHeight(0.85);
+      ls->m_ScalarBarActor->SetPosition(0.05, (1.0 - this->GetLenght() / float(size[1])) * 0.5);
+      ls->m_ScalarBarActor->SetWidth(this->GetWidth() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetLenght() / float(size[1]));
     }
     else
     {
-      ls->m_ScalarBarActor->SetPosition(0.03, 0.03);
-      ls->m_ScalarBarActor->SetWidth(0.8);
-      ls->m_ScalarBarActor->SetHeight(0.15);
+      ls->m_ScalarBarActor->SetPosition((1.0 - this->GetLenght() / float(size[0])) * 0.5, 0.05);
+      ls->m_ScalarBarActor->SetWidth(this->GetLenght() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetWidth() / float(size[1]));
     }
   }
 }
diff --git a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
index d07d3dfb93..b07760c899 100644
--- a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
+++ b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
@@ -70,6 +70,7 @@ void mitk::ScaleLegendAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *render
     ls->m_legendScaleActor->GetRightAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetTopAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetBottomAxis()->SetFontFactor(this->GetFontFactor());
+    ls->m_legendScaleActor->SetLabelModeToDistance();
   }
 }
 
diff --git a/Modules/Annotation/src/mitkTextAnnotation2D.cpp b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
index 24fab05733..84e029482c 100644
--- a/Modules/Annotation/src/mitkTextAnnotation2D.cpp
+++ b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
@@ -96,13 +96,12 @@ void mitk::TextAnnotation2D::UpdateVtkAnnotation2D(mitk::BaseRenderer *renderer)
     float opacity = 1.0;
     GetColor(color);
     GetOpacity(opacity);
-    ls->m_TextProp->SetColor(color[0], color[1], color[2]);
     ls->m_STextProp->SetColor(0, 0, 0);
-    ls->m_TextProp->SetFontSize(GetFontSize());
-    ls->m_TextProp->SetOpacity(opacity);
     ls->m_STextProp->SetFontSize(GetFontSize());
     ls->m_STextProp->SetOpacity(opacity);
-
+    ls->m_TextProp->SetColor(color[0], color[1], color[2]);
+    ls->m_TextProp->SetFontSize(GetFontSize());
+    ls->m_TextProp->SetOpacity(opacity);
     std::string fontFamilyAsString;
     if (GetStringProperty("font.family", fontFamilyAsString) == false)
     {
diff --git a/Modules/AppUtil/src/mitkBaseApplication.cpp b/Modules/AppUtil/src/mitkBaseApplication.cpp
index e41a40fe79..7c47ea5b01 100644
--- a/Modules/AppUtil/src/mitkBaseApplication.cpp
+++ b/Modules/AppUtil/src/mitkBaseApplication.cpp
@@ -660,6 +660,7 @@ namespace mitk
 #endif
 
       QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
+      QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
 
       d->m_QApp = this->getSingleMode()
         ? static_cast<QCoreApplication*>(new QmitkSingleApplication(d->m_Argc, d->m_Argv, this->getSafeMode()))
diff --git a/Modules/Core/TestingHelper/include/mitkTestFixture.h b/Modules/Core/TestingHelper/include/mitkTestFixture.h
index f0c881fae8..5bd9c5910a 100644
--- a/Modules/Core/TestingHelper/include/mitkTestFixture.h
+++ b/Modules/Core/TestingHelper/include/mitkTestFixture.h
@@ -111,6 +111,21 @@ namespace mitk
       return std::string(MITK_DATA_DIR) + "/" + testData;
     }
 
+
+    /**
+     * \brief Get the absolute path for project specific test data.
+     *
+     * \param testData The realative path in the project specific test data repository.
+     *
+     * \return The absolute path for the project specific test data.
+     */
+    static std::string GetTestDataFilePath(const std::string &testData, const std::string &project )
+    {
+      if (itksys::SystemTools::FileIsFullPath(testData.c_str()))
+        return testData;
+      return project + "/" + testData;
+    }
+
   private:
     template <class P>
     friend class TestCaller;
diff --git a/Modules/Core/include/Colortables/Civids.h b/Modules/Core/include/Colortables/Civids.h
new file mode 100644
index 0000000000..81af16e57d
--- /dev/null
+++ b/Modules/Core/include/Colortables/Civids.h
@@ -0,0 +1,53 @@
+/*============================================================================
+
+The Medical Imaging Interaction Toolkit (MITK)
+
+Copyright (c) German Cancer Research Center (DKFZ)
+All rights reserved.
+
+Use of this source code is governed by a 3-clause BSD license that can be
+found in the LICENSE file.
+
+============================================================================*/
+
+#pragma once
+
+static const int Civids[256][3] = {
+  {0, 32, 76},     {0, 32, 78},     {0, 33, 80},     {0, 34, 81},     {0, 35, 83},     {0, 35, 85},     {0, 36, 86},
+  {0, 37, 88},     {0, 38, 90},     {0, 38, 91},     {0, 39, 93},     {0, 40, 95},     {0, 40, 97},     {0, 41, 99},
+  {0, 42, 100},    {0, 42, 102},    {0, 43, 104},    {0, 44, 106},    {0, 45, 108},    {0, 45, 109},    {0, 46, 110},
+  {0, 46, 111},    {0, 47, 111},    {0, 47, 111},    {0, 48, 111},    {0, 49, 111},    {0, 49, 111},    {0, 50, 110},
+  {0, 51, 110},    {0, 52, 110},    {0, 52, 110},    {1, 53, 110},    {6, 54, 110},    {10, 55, 109},   {14, 55, 109},
+  {18, 56, 109},   {21, 57, 109},   {23, 57, 109},   {26, 58, 108},   {28, 59, 108},   {30, 60, 108},   {32, 60, 108},
+  {34, 61, 108},   {36, 62, 108},   {38, 62, 108},   {39, 63, 108},   {41, 64, 107},   {43, 65, 107},   {44, 65, 107},
+  {46, 66, 107},   {47, 67, 107},   {49, 68, 107},   {50, 68, 107},   {51, 69, 107},   {53, 70, 107},   {54, 70, 107},
+  {55, 71, 107},   {56, 72, 107},   {58, 73, 107},   {59, 73, 107},   {60, 74, 107},   {61, 75, 107},   {62, 75, 107},
+  {64, 76, 107},   {65, 77, 107},   {66, 78, 107},   {67, 78, 107},   {68, 79, 107},   {69, 80, 107},   {70, 80, 107},
+  {71, 81, 107},   {72, 82, 107},   {73, 83, 107},   {74, 83, 107},   {75, 84, 107},   {76, 85, 107},   {77, 85, 107},
+  {78, 86, 107},   {79, 87, 108},   {80, 88, 108},   {81, 88, 108},   {82, 89, 108},   {83, 90, 108},   {84, 90, 108},
+  {85, 91, 108},   {86, 92, 108},   {87, 93, 109},   {88, 93, 109},   {89, 94, 109},   {90, 95, 109},   {91, 95, 109},
+  {92, 96, 109},   {93, 97, 110},   {94, 98, 110},   {95, 98, 110},   {95, 99, 110},   {96, 100, 110},  {97, 101, 111},
+  {98, 101, 111},  {99, 102, 111},  {100, 103, 111}, {101, 103, 111}, {102, 104, 112}, {103, 105, 112}, {104, 106, 112},
+  {104, 106, 112}, {105, 107, 113}, {106, 108, 113}, {107, 109, 113}, {108, 109, 114}, {109, 110, 114}, {110, 111, 114},
+  {111, 111, 114}, {111, 112, 115}, {112, 113, 115}, {113, 114, 115}, {114, 114, 116}, {115, 115, 116}, {116, 116, 117},
+  {117, 117, 117}, {117, 117, 117}, {118, 118, 118}, {119, 119, 118}, {120, 120, 118}, {121, 120, 119}, {122, 121, 119},
+  {123, 122, 119}, {123, 123, 120}, {124, 123, 120}, {125, 124, 120}, {126, 125, 120}, {127, 126, 120}, {128, 126, 120},
+  {129, 127, 120}, {130, 128, 120}, {131, 129, 120}, {132, 129, 120}, {133, 130, 120}, {134, 131, 120}, {135, 132, 120},
+  {136, 133, 120}, {137, 133, 120}, {138, 134, 120}, {139, 135, 120}, {140, 136, 120}, {141, 136, 120}, {142, 137, 120},
+  {143, 138, 120}, {144, 139, 120}, {145, 140, 120}, {146, 140, 120}, {147, 141, 120}, {148, 142, 120}, {149, 143, 120},
+  {150, 143, 119}, {151, 144, 119}, {152, 145, 119}, {153, 146, 119}, {154, 147, 119}, {155, 147, 119}, {156, 148, 119},
+  {157, 149, 119}, {158, 150, 118}, {159, 151, 118}, {160, 152, 118}, {161, 152, 118}, {162, 153, 118}, {163, 154, 117},
+  {164, 155, 117}, {165, 156, 117}, {166, 156, 117}, {167, 157, 117}, {168, 158, 116}, {169, 159, 116}, {170, 160, 116},
+  {171, 161, 116}, {172, 161, 115}, {173, 162, 115}, {174, 163, 115}, {175, 164, 115}, {176, 165, 114}, {177, 166, 114},
+  {178, 166, 114}, {180, 167, 113}, {181, 168, 113}, {182, 169, 113}, {183, 170, 112}, {184, 171, 112}, {185, 171, 112},
+  {186, 172, 111}, {187, 173, 111}, {188, 174, 110}, {189, 175, 110}, {190, 176, 110}, {191, 177, 109}, {192, 177, 109},
+  {193, 178, 108}, {194, 179, 108}, {196, 180, 108}, {197, 181, 107}, {198, 182, 107}, {199, 183, 106}, {200, 184, 106},
+  {201, 184, 105}, {202, 185, 105}, {203, 186, 104}, {204, 187, 104}, {205, 188, 103}, {206, 189, 103}, {207, 190, 102},
+  {209, 191, 102}, {210, 192, 101}, {211, 192, 101}, {212, 193, 100}, {213, 194, 99},  {214, 195, 99},  {215, 196, 98},
+  {216, 197, 98},  {217, 198, 97},  {219, 199, 96},  {220, 200, 96},  {221, 201, 95},  {222, 202, 94},  {223, 203, 93},
+  {224, 203, 93},  {225, 204, 92},  {227, 205, 91},  {228, 206, 91},  {229, 207, 90},  {230, 208, 89},  {231, 209, 88},
+  {232, 210, 87},  {233, 211, 86},  {235, 212, 86},  {236, 213, 85},  {237, 214, 84},  {238, 215, 83},  {239, 216, 82},
+  {240, 217, 81},  {242, 218, 80},  {243, 219, 79},  {244, 220, 78},  {245, 221, 77},  {246, 222, 76},  {247, 223, 75},
+  {249, 224, 73},  {250, 224, 72},  {251, 225, 71},  {252, 226, 70},  {253, 227, 69},  {255, 228, 67},  {255, 229, 66},
+  {255, 230, 66},  {255, 231, 67},  {255, 232, 68},  {255, 233, 69}
+};
\ No newline at end of file
diff --git a/Modules/Core/include/mitkLookupTable.h b/Modules/Core/include/mitkLookupTable.h
index 5ab7de7dba..421c466d85 100644
--- a/Modules/Core/include/mitkLookupTable.h
+++ b/Modules/Core/include/mitkLookupTable.h
@@ -210,7 +210,12 @@ namespace mitk
       LEGACY_RAINBOW_COLOR,
       MULTILABEL,
       PET_COLOR,
-      PET_20
+      PET_20,
+      GRAYSCALE_TRANSPARENT,
+      HOT_IRON_TRANSPARENT,
+      VIRIDIS_TRANSPARENT,
+      CIVIDS_TRANSPARENT,
+      CIVIDS,
     };
 
     static std::vector<std::string> typenameList;
@@ -244,14 +249,15 @@ namespace mitk
 
     LookupTable(const LookupTable &other);
 
-    virtual void BuildGrayScaleLookupTable();
+    virtual void BuildGrayScaleLookupTable(bool transparent = false);
     virtual void BuildLegacyBinaryLookupTable();
     virtual void BuildLegacyRainbowColorLookupTable();
     virtual void BuildInverseGrayScaleLookupTable();
-    virtual void BuildHotIronLookupTable();
-	  virtual void BuildPlasmaLookupTable();
+    virtual void BuildHotIronLookupTable(bool transparent = false);
+    virtual void BuildPlasmaLookupTable();
 	  virtual void BuildInfernoLookupTable();
-	  virtual void BuildViridisLookupTable();
+    virtual void BuildViridisLookupTable(bool transparent = false);
+    virtual void BuildCividsLookupTable(bool transparent = false);
     virtual void BuildMagmaLookupTable();
     virtual void BuildJetLookupTable(bool transparent = false);
     virtual void BuildPETColorLookupTable();
diff --git a/Modules/Core/src/DataManagement/mitkImage.cpp b/Modules/Core/src/DataManagement/mitkImage.cpp
index 4ed855b751..381bd0aebe 100644
--- a/Modules/Core/src/DataManagement/mitkImage.cpp
+++ b/Modules/Core/src/DataManagement/mitkImage.cpp
@@ -939,7 +939,7 @@ void mitk::Image::Initialize(const mitk::PixelType &type,
   dimensions[4] = 0;
 
   unsigned int dimension = 2;
-  if (dimensions[2] > 1)
+  if (dimensions[2] >= 1)
     dimension = 3;
   if (dimensions[3] > 1)
     dimension = 4;
diff --git a/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp b/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
index 5c4786a10a..4ff01ced03 100644
--- a/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
+++ b/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
@@ -18,6 +18,7 @@ found in the LICENSE file.
 namespace mitk
 {
   typedef itk::Image<itk::RGBPixel<unsigned char>, 2> itkImageRGBUC2;
+  typedef itk::Image<itk::RGBAPixel<unsigned char>, 2> itkImageRGBAUC2;
   typedef itk::Image<itk::DiffusionTensor3D<float>, 2> itkImageDTIF2;
   typedef itk::Image<itk::DiffusionTensor3D<double>, 2> itkImageDTID2;
 
@@ -32,6 +33,16 @@ namespace mitk
                            itkOutputImage);
   }
   template <>
+  void MITKCORE_EXPORT CastToItkImage(const mitk::Image *mitkImage, itk::SmartPointer<itkImageRGBAUC2> &itkOutputImage)
+  {
+    typedef itkImageRGBAUC2 ItkOutputImageType;
+    AccessFixedTypeByItk_1(mitkImage,
+                           _CastToItkImage2Access,
+                           (itk::RGBAPixel<unsigned char>),
+                           (ItkOutputImageType::ImageDimension),
+                           itkOutputImage);
+  }
+  template <>
   void MITKCORE_EXPORT CastToItkImage(const mitk::Image *mitkImage, itk::SmartPointer<itkImageDTIF2> &itkOutputImage)
   {
     typedef itkImageDTIF2 ItkOutputImageType;
diff --git a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
index c0b04c6570..f8ac8f7d8d 100644
--- a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
+++ b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
@@ -555,7 +555,8 @@ mitk::DataStorage::SetOfObjects::ConstPointer mitk::LevelWindowManager::GetRelev
   NodePredicateProperty::Pointer notBinary = NodePredicateProperty::New("binary", BoolProperty::New(false));
   NodePredicateProperty::Pointer hasLevelWindow = NodePredicateProperty::New("levelwindow", nullptr);
 
-  NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  //NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  auto isImage = TNodePredicateDataType<mitk::Image>::New();
   NodePredicateDataType::Pointer isDImage = NodePredicateDataType::New("DiffusionImage");
   NodePredicateDataType::Pointer isTImage = NodePredicateDataType::New("TensorImage");
   NodePredicateDataType::Pointer isOdfImage = NodePredicateDataType::New("OdfImage");
diff --git a/Modules/Core/src/DataManagement/mitkLookupTable.cpp b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
index 3022e09869..8dcf01e761 100644
--- a/Modules/Core/src/DataManagement/mitkLookupTable.cpp
+++ b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
@@ -11,63 +11,64 @@ found in the LICENSE file.
 ============================================================================*/
 
 #include "mitkLookupTable.h"
-#include <itkProcessObject.h>
-
-#include <vtkColorTransferFunction.h>
-#include <vtkPiecewiseFunction.h>
 
+#include <Colortables/Civids.h>
 #include <Colortables/HotIron.h>
-#include <Colortables/Jet.h>
 #include <Colortables/Inferno.h>
-#include <Colortables/Viridis.h>
-#include <Colortables/Plasma.h>
+#include <Colortables/Jet.h>
 #include <Colortables/Magma.h>
 #include <Colortables/Multilabel.h>
 #include <Colortables/PET20.h>
 #include <Colortables/PETColor.h>
+#include <Colortables/Plasma.h>
+#include <Colortables/Viridis.h>
+#include <itkProcessObject.h>
 #include <mitkLookupTableProperty.h>
+#include <vtkColorTransferFunction.h>
+#include <vtkPiecewiseFunction.h>
 
-std::vector<std::string> mitk::LookupTable::typenameList = {
-  "Grayscale",
-  "Inverse Grayscale",
-  "Hot Iron",
-  "Jet",
-  "Jet Transparent",
-  "Plasma",
-  "Inferno",
-  "Viridis",
-  "Magma",
-  "Legacy Binary",
-  "Legacy Rainbow Color",
-  "Multilabel",
-  "PET Color",
-  "PET 20"
-};
+std::vector<std::string> mitk::LookupTable::typenameList = {"Grayscale",
+                                                            "Inverse Grayscale",
+                                                            "Hot Iron",
+                                                            "Jet",
+                                                            "Jet Transparent",
+                                                            "Plasma",
+                                                            "Inferno",
+                                                            "Viridis",
+                                                            "Magma",
+                                                            "Legacy Binary",
+                                                            "Legacy Rainbow Color",
+                                                            "Multilabel",
+                                                            "PET Color",
+                                                            "PET 20",
+                                                            "Grayscale Transparent",
+                                                            "Hot Iron Transparent",
+                                                            "Viridis Transparent",
+                                                            "Civids Transparent",
+                                                            "Civids"};
 
 mitk::LookupTable::LookupTable()
-  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(0.0)
-  , m_Level(0.0)
-  , m_Opacity(1.0)
-  , m_Type(mitk::LookupTable::GRAYSCALE)
+  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(0.0),
+    m_Level(0.0),
+    m_Opacity(1.0),
+    m_Type(mitk::LookupTable::GRAYSCALE)
 {
   this->BuildGrayScaleLookupTable();
 }
 
 mitk::LookupTable::LookupTable(const LookupTable &other)
-  : itk::DataObject()
-  , m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(other.m_Window)
-  , m_Level(other.m_Level)
-  , m_Opacity(other.m_Opacity)
-  , m_Type(other.m_Type)
+  : itk::DataObject(),
+    m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(other.m_Window),
+    m_Level(other.m_Level),
+    m_Opacity(other.m_Opacity),
+    m_Type(other.m_Type)
 {
   m_LookupTable->DeepCopy(other.m_LookupTable);
 }
 
-mitk::LookupTable::~LookupTable()
-{
-}
+mitk::LookupTable::~LookupTable() {}
 
 void mitk::LookupTable::SetVtkLookupTable(vtkSmartPointer<vtkLookupTable> lut)
 {
@@ -87,6 +88,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
 
   switch (type)
   {
+    case (mitk::LookupTable::GRAYSCALE_TRANSPARENT):
+      this->BuildGrayScaleLookupTable(true);
+      break;
     case (mitk::LookupTable::GRAYSCALE):
       this->BuildGrayScaleLookupTable();
       break;
@@ -96,6 +100,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
     case (mitk::LookupTable::HOT_IRON):
       this->BuildHotIronLookupTable();
       break;
+    case (mitk::LookupTable::HOT_IRON_TRANSPARENT):
+      this->BuildHotIronLookupTable(true);
+      break;
     case (mitk::LookupTable::JET):
       this->BuildJetLookupTable();
       break;
@@ -103,14 +110,23 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
       this->BuildJetLookupTable(true);
       break;
     case (mitk::LookupTable::PLASMA):
-	    this->BuildPlasmaLookupTable();
-	    break;
-	  case (mitk::LookupTable::INFERNO):
-	    this->BuildInfernoLookupTable();
+      this->BuildPlasmaLookupTable();
+      break;
+    case (mitk::LookupTable::INFERNO):
+      this->BuildInfernoLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS):
+      this->BuildViridisLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS_TRANSPARENT):
+      this->BuildViridisLookupTable(true);
+      break;
+    case (mitk::LookupTable::CIVIDS_TRANSPARENT):
+      this->BuildCividsLookupTable(true);
+      break;
+    case (mitk::LookupTable::CIVIDS):
+      this->BuildCividsLookupTable(false);
       break;
-	  case (mitk::LookupTable::VIRIDIS):
-	    this->BuildViridisLookupTable();
-	    break;
     case (mitk::LookupTable::MAGMA):
       this->BuildMagmaLookupTable();
       break;
@@ -285,9 +301,7 @@ void mitk::LookupTable::UpdateOutputInformation()
   }
 }
 
-void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion()
-{
-}
+void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion() {}
 
 bool mitk::LookupTable::RequestedRegionIsOutsideOfTheBufferedRegion()
 {
@@ -411,7 +425,7 @@ itk::LightObject::Pointer mitk::LookupTable::InternalClone() const
   return result;
 }
 
-void mitk::LookupTable::BuildGrayScaleLookupTable()
+void mitk::LookupTable::BuildGrayScaleLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetRampToLinear();
@@ -420,6 +434,11 @@ void mitk::LookupTable::BuildGrayScaleLookupTable()
   lut->SetValueRange(0.0, 1.0);
   lut->Build();
 
+  if (transparent)
+  {
+    lut->SetTableValue(0, 0.0, 0.0, 0.0, 0.0);
+  }
+
   m_LookupTable = lut;
   this->Modified();
 }
@@ -452,13 +471,22 @@ void mitk::LookupTable::BuildInverseGrayScaleLookupTable()
   this->Modified();
 }
 
-void mitk::LookupTable::BuildHotIronLookupTable()
+void mitk::LookupTable::BuildHotIronLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetNumberOfTableValues(256);
   lut->Build();
+  int i = 0;
 
-  for (int i = 0; i < 256; i++)
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)HotIron[0][0] / 255.0, (double)HotIron[0][1] / 255.0, (double)HotIron[0][2] / 255.0, 0.0);
+    i = 1;
+  }
+
+  for (; i < 256; i++)
   {
     lut->SetTableValue(
       i, (double)HotIron[i][0] / 255.0, (double)HotIron[i][1] / 255.0, (double)HotIron[i][2] / 255.0, 1.0);
@@ -535,7 +563,7 @@ void mitk::LookupTable::BuildMultiLabelLookupTable()
 
   for (int i = 0; i < 25; i++)
   {
-    lut->SetTableValue(i+1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
+    lut->SetTableValue(i + 1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
   }
 
   for (int i = 26; i < 65536; i++)
@@ -584,50 +612,84 @@ void mitk::LookupTable::BuildLegacyRainbowColorLookupTable()
 
 void mitk::LookupTable::BuildPlasmaLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
-	}
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildInfernoLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
+
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
+  }
+
+  m_LookupTable = lut;
+  this->Modified();
+}
+
+void mitk::LookupTable::BuildViridisLookupTable(bool transparent)
+{
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
+
+  int i = 0;
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)Viridis[0][0] / 255.0, (double)Viridis[0][1] / 255.0, (double)Viridis[0][2] / 255.0, 0.0);
+    i = 1;
+  }
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
-	}
+  for (; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
-void mitk::LookupTable::BuildViridisLookupTable()
+void mitk::LookupTable::BuildCividsLookupTable(bool transparent)
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
+
+  int i = 0;
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)Civids[0][0] / 255.0, (double)Civids[0][1] / 255.0, (double)Civids[0][2] / 255.0, 0.0);
+    i = 1;
+  }
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
-	}
+  for (; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Civids[i][0] / 255.0, (double)Civids[i][1] / 255.0, (double)Civids[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildMagmaLookupTable()
@@ -638,8 +700,7 @@ void mitk::LookupTable::BuildMagmaLookupTable()
 
   for (int i = 0; i < 256; i++)
   {
-    lut->SetTableValue(
-      i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
+    lut->SetTableValue(i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
   }
 
   m_LookupTable = lut;
diff --git a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
index cfecd85744..8c40ae6d85 100644
--- a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
+++ b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
@@ -147,7 +147,7 @@ void mitk::PointSetDataInteractor::SelectPoint(StateMachineAction *, Interaction
   }
 }
 
-mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(3.5)
+mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(0.025)
 {
 }
 
diff --git a/Modules/CppMicroServices/third_party/jsoncpp.cpp b/Modules/CppMicroServices/third_party/jsoncpp.cpp
index e4d9ea08a6..d029e60b4a 100644
--- a/Modules/CppMicroServices/third_party/jsoncpp.cpp
+++ b/Modules/CppMicroServices/third_party/jsoncpp.cpp
@@ -1725,7 +1725,7 @@ Value::CZString::operator =( const CZString &other )
 bool
 Value::CZString::operator<( const CZString &other ) const
 {
-   if ( cstr_ )
+   if ( cstr_ && other.cstr_)
       return strcmp( cstr_, other.cstr_ ) < 0;
    return index_ < other.index_;
 }
@@ -1733,7 +1733,7 @@ Value::CZString::operator<( const CZString &other ) const
 bool
 Value::CZString::operator==( const CZString &other ) const
 {
-   if ( cstr_ )
+   if ( cstr_ && other.cstr_)
       return strcmp( cstr_, other.cstr_ ) == 0;
    return index_ == other.index_;
 }
diff --git a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
index 623924f0b3..f549e3610a 100644
--- a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
+++ b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
@@ -17,6 +17,7 @@ found in the LICENSE file.
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkNodePredicateNot.h>
+#include <mitkImage.h>
 
 namespace mitk
 {
@@ -30,7 +31,7 @@ namespace mitk
 
   mitk::NodePredicateBase::Pointer GetImageStatisticsImagePredicate()
   {
-    auto isImage = mitk::NodePredicateDataType::New("Image");
+    auto isImage = mitk::TNodePredicateDataType<mitk::Image>::New();
     auto hasBinaryProperty = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
     auto isNotBinary = mitk::NodePredicateNot::New(hasBinaryProperty);
     auto isNotBinaryImage = mitk::NodePredicateAnd::New(isImage, isNotBinary);
diff --git a/Modules/ModuleList.cmake b/Modules/ModuleList.cmake
index c36c213269..3c56112dde 100644
--- a/Modules/ModuleList.cmake
+++ b/Modules/ModuleList.cmake
@@ -34,46 +34,46 @@ set(MITK_MODULES
   SegmentationUI
   MatchPointRegistration
   MatchPointRegistrationUI
-  Classification
-  OpenIGTLink
-  IGTBase
-  IGT
-  CameraCalibration
-  OpenCL
-  OpenCVVideoSupport
+  #Classification
+  #OpenIGTLink
+  #IGTBase
+  #IGT
+  #CameraCalibration
+  # OpenCL
+  #OpenCVVideoSupport
   QtOverlays
-  ToFHardware
-  ToFProcessing
-  ToFUI
-  US
-  USUI
+  #ToFHardware
+  #ToFProcessing
+  #ToFUI
+  #US
+  #USUI
   DICOMUI
   Remeshing
-  Python
-  QtPython
+  #Python
+  #QtPython
   Persistence
-  OpenIGTLinkUI
-  IGTUI
-  RT
-  RTUI
+  #OpenIGTLinkUI
+  #IGTUI
+  #RT
+  #RTUI
   IOExt
-  XNAT
+  #XNAT
   TubeGraph
   BoundingShape
   RenderWindowManager
   RenderWindowManagerUI
-  SemanticRelations
-  SemanticRelationsUI
-  CEST
+  #SemanticRelations
+  #SemanticRelationsUI
+  #CEST
   BasicImageProcessing
-  ModelFit
-  ModelFitUI
-  Pharmacokinetics
-  PharmacokineticsUI
-  DICOMPM
-  REST
-  RESTService
-  DICOMweb
+  #ModelFit
+  #ModelFitUI
+  #Pharmacokinetics
+  #PharmacokineticsUI
+  #DICOMPM
+  #REST
+  #RESTService
+  #DICOMweb
 )
 
 if(MITK_ENABLE_PIC_READER)
diff --git a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
index 46a8600375..27b7ece498 100644
--- a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
+++ b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
@@ -13,10 +13,12 @@ found in the LICENSE file.
 #include "QmitkNodeDescriptorManager.h"
 #include <memory>
 #include <mitkNodePredicateAnd.h>
+#include <mitkNodePredicateOr.h>
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateNot.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkProperties.h>
+#include <mitkImage.h>
 
 #include <QList>
 #include <QSet>
@@ -35,6 +37,13 @@ void QmitkNodeDescriptorManager::Initialize()
   auto isMultiComponentImage = mitk::NodePredicateAnd::New(isImage, mitk::NodePredicateProperty::New("Image.Displayed Component"));
   AddDescriptor(new QmitkNodeDescriptor(tr("MultiComponentImage"), QString(": / Qmitk / Images_48.png"), isMultiComponentImage, this));
 
+  auto a = mitk::NodePredicateDataType::New("SpectrumImageStack");
+  auto b = mitk::NodePredicateDataType::New("ImzMLSpectrumImage");
+  auto c = mitk::NodePredicateOr::New(a, b);
+  auto f = mitk::TNodePredicateDataType<mitk::Image>::New();
+  auto g = mitk::NodePredicateAnd::New(c, f);
+  AddDescriptor( new QmitkNodeDescriptor(tr("SpectrumImage"), QString(":/Qmitk/LabelSetImage_48.png"), g, this));
+
   auto isBinary = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
   auto isBinaryImage = mitk::NodePredicateAnd::New(isBinary, isImage);
   AddDescriptor(new QmitkNodeDescriptor(tr("ImageMask"), QString(":/Qmitk/Binaerbilder_48.png"), isBinaryImage, this));
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
index a8a7e00ce6..a431349cc0 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
@@ -11,7 +11,16 @@ found in the LICENSE file.
 ============================================================================*/
 
 #include <QmitkDataNodeContextMenu.h>
+#include "QmitkDataNodeContextMenu.h"
 
+// mitk gui qt application plugin
+#include "QmitkFileSaveAction.h"
+#include "mitkIContextMenuAction.h"
+
+// mitk gui common plugin
+#include <mitkDataNodeSelection.h>
+
+// qt widgets module
 #include <QmitkCustomVariants.h>
 #include <QmitkFileSaveAction.h>
 #include <QmitkNodeDescriptorManager.h>
@@ -101,6 +110,8 @@ void QmitkDataNodeContextMenu::InitNodeDescriptors()
   m_PlanarDoubleEllipseNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarDoubleEllipse");
   m_PlanarBezierCurveNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarBezierCurve");
   m_PlanarSubdivisionPolygonNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarSubdivisionPolygon");
+  m_ImzMLMassSpecImageNodeDescriptor = nodeDescriptorManager->GetDescriptor("SpectrumImage");
+
 }
 
 void QmitkDataNodeContextMenu::InitDefaultActions()
@@ -145,48 +156,49 @@ void QmitkDataNodeContextMenu::InitDefaultActions()
   m_UnknownDataNodeDescriptor->AddAction(m_OpacityAction, false);
   m_DescriptorActionList.push_back(std::make_pair(m_UnknownDataNodeDescriptor, m_OpacityAction));
 
-  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, workbenchPartSite);
-  this->AddColorAction(m_ColorAction);
-
-  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_ColormapAction);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_ColormapAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ColormapAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ColormapAction));
-  }
-
-  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, workbenchPartSite);
-  m_MultiComponentImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, m_ComponentAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ComponentAction));
-  }
-
-  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_TextureInterpolationAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_TextureInterpolationAction));
-  }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, m_TextureInterpolationAction));
-  }
+  auto all = {m_ImageDataNodeDescriptor,
+              m_ImzMLMassSpecImageNodeDescriptor,
+              m_MultiComponentImageDataNodeDescriptor,
+              m_DiffusionImageDataNodeDescriptor,
+              m_FiberBundleDataNodeDescriptor,
+              m_PeakImageDataNodeDescriptor,
+              m_SegmentDataNodeDescriptor,
+              m_SurfaceDataNodeDescriptor,
+              m_PointSetNodeDescriptor,
+              m_PlanarLineNodeDescriptor,
+              m_PlanarCircleNodeDescriptor,
+              m_PlanarEllipseNodeDescriptor,
+              m_PlanarAngleNodeDescriptor,
+              m_PlanarFourPointAngleNodeDescriptor,
+              m_PlanarRectangleNodeDescriptor,
+              m_PlanarPolygonNodeDescriptor,
+              m_PlanarPathNodeDescriptor,
+              m_PlanarDoubleEllipseNodeDescriptor,
+              m_PlanarBezierCurveNodeDescriptor,
+              m_PlanarSubdivisionPolygonNodeDescriptor};
+
+  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColorAction, all, true);
+
+  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColormapAction,
+            {m_ImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor, m_ImzMLMassSpecImageNodeDescriptor},
+            true);
+
+  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ComponentAction, {m_MultiComponentImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor}, false);
+
+  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_TextureInterpolationAction,
+            {m_ImageDataNodeDescriptor,
+             m_DiffusionImageDataNodeDescriptor,
+             m_ImzMLMassSpecImageNodeDescriptor,
+             m_SegmentDataNodeDescriptor},
+            false);
+
+  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_SurfaceRepresentationAction, {m_SurfaceDataNodeDescriptor}, false);
 
-  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, workbenchPartSite);
-  m_SurfaceDataNodeDescriptor->AddAction(m_SurfaceRepresentationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, m_SurfaceRepresentationAction));
 }
 
 void QmitkDataNodeContextMenu::InitExtensionPointActions()
@@ -194,7 +206,9 @@ void QmitkDataNodeContextMenu::InitExtensionPointActions()
   auto extensionPointService = berry::Platform::GetExtensionRegistry();
   auto customMenuConfigs = extensionPointService->GetConfigurationElementsFor("org.mitk.gui.qt.datamanager.contextMenuActions");
 
+
   DescriptorActionListType descriptorActionList;
+
   m_ConfigElements.clear();
 
   for (const auto& customMenuConfig : qAsConst(customMenuConfigs))
@@ -310,125 +324,22 @@ void QmitkDataNodeContextMenu::OnExtensionPointActionTriggered(QAction* action)
   contextMenuAction->Run(m_SelectedNodes);
 }
 
-void QmitkDataNodeContextMenu::AddColorAction(QWidgetAction* colorAction)
+void QmitkDataNodeContextMenu::AddAction(QAction *action, std::vector<QmitkNodeDescriptor *> list, bool canBatch)
 {
-  if (nullptr != m_ImageDataNodeDescriptor)
-  {
-    m_ImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_MultiComponentImageDataNodeDescriptor)
-  {
-    m_MultiComponentImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, colorAction));
-  }
 
-  if (nullptr != m_FiberBundleDataNodeDescriptor)
+  for (auto *descriptor : list)
   {
-    m_FiberBundleDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_FiberBundleDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PeakImageDataNodeDescriptor)
+    if (nullptr != descriptor)
   {
-    m_PeakImageDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_PeakImageDataNodeDescriptor, colorAction));
+      descriptor->AddAction(action, canBatch);
+      m_DescriptorActionList.push_back(std::make_pair(descriptor, action));
   }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, colorAction));
   }
-
-  if (nullptr != m_SurfaceDataNodeDescriptor)
-  {
-    m_SurfaceDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, colorAction));
   }
 
-  if (nullptr != m_PointSetNodeDescriptor)
+void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType &descriptorActionList)
   {
-    m_PointSetNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PointSetNodeDescriptor, colorAction));
-  }
 
-  if (nullptr != m_PlanarLineNodeDescriptor)
-  {
-    m_PlanarLineNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarLineNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarCircleNodeDescriptor)
-  {
-    m_PlanarCircleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarCircleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarEllipseNodeDescriptor)
-  {
-    m_PlanarEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarAngleNodeDescriptor)
-  {
-    m_PlanarAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarAngleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarFourPointAngleNodeDescriptor)
-  {
-    m_PlanarFourPointAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarFourPointAngleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarRectangleNodeDescriptor)
-  {
-    m_PlanarRectangleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarRectangleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPolygonNodeDescriptor)
-  {
-    m_PlanarPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPolygonNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPathNodeDescriptor)
-  {
-    m_PlanarPathNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPathNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarDoubleEllipseNodeDescriptor)
-  {
-    m_PlanarDoubleEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarDoubleEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarBezierCurveNodeDescriptor)
-  {
-    m_PlanarBezierCurveNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarBezierCurveNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarSubdivisionPolygonNodeDescriptor)
-  {
-    m_PlanarSubdivisionPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarSubdivisionPolygonNodeDescriptor, colorAction));
-  }
-}
-
-void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType& descriptorActionList)
-{
   using ListItem = std::pair<QmitkNodeDescriptor*, QAction*>;
 
   std::sort(descriptorActionList.begin(), descriptorActionList.end(), [](const ListItem& left, const ListItem& right) -> bool
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
index 2dcf8ba901..3428e42c02 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
@@ -74,7 +74,7 @@ private:
   void InitExtensionPointActions();
   void InitServiceActions();
 
-  void AddColorAction(QWidgetAction* colorAction);
+  void AddAction(QAction *colorAction, std::vector<QmitkNodeDescriptor *> list, bool canBatch = false);
   void AddDescriptorActionList(DescriptorActionListType& descriptorActionList);
 
   QList<QAction*> GetActions(const mitk::DataNode* node);
@@ -113,6 +113,7 @@ private:
   QmitkNodeDescriptor* m_PlanarDoubleEllipseNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarBezierCurveNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarSubdivisionPolygonNodeDescriptor;
+  QmitkNodeDescriptor* m_ImzMLMassSpecImageNodeDescriptor;
 
   //////////////////////////////////////////////////////////////////////////
   // default actions
diff --git a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
index d301680b15..61665c7e4f 100644
--- a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
+++ b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
@@ -159,7 +159,7 @@ void QmitkMultiWidgetDecorationManager::SetupLogo(const char* path)
   mitk::Point2D offset;
   offset.Fill(0.03);
   m_LogoAnnotation->SetOffsetVector(offset);
-  m_LogoAnnotation->SetRelativeSize(0.25);
+  m_LogoAnnotation->SetRelativeSize(0.15);
   m_LogoAnnotation->SetCornerPosition(1);
   vtkSmartPointer<vtkImageData> vtkLogo = GetVtkLogo(path);
 
diff --git a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
index dfbd27ae6a..adbbb9ced7 100755
--- a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
+++ b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
@@ -34,6 +34,13 @@ QmitkPointSetInteractionView::~QmitkPointSetInteractionView()
 {
 }
 
+void QmitkPointSetInteractionView::OnSelectionChanged(berry::IWorkbenchPart::Pointer /*source*/,
+                                                      const QList<mitk::DataNode::Pointer> &nodes)
+{
+  if(nodes.size() == 1)
+    m_Controls->selectedPointSetWidget->SetCurrentSelectedNode(nodes.front());
+}
+
 void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
 {
   m_Controls = new Ui::QmitkPointSetInteractionViewControls;
@@ -47,7 +54,7 @@ void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
       mitk::NodePredicateProperty::New("hidden object")))));
 
   m_Controls->selectedPointSetWidget->SetSelectionIsOptional(true);
-  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(true);
+  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(false);
   m_Controls->selectedPointSetWidget->SetEmptyInfo(QString("Please select a point set"));
   m_Controls->selectedPointSetWidget->SetPopUpTitel(QString("Select point set"));
 
diff --git a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
index c7bc89fc2e..9ab7f94d0b 100755
--- a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
+++ b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
@@ -45,6 +45,8 @@ private Q_SLOT:
 private:
 
   void CreateQtPartControl(QWidget *parent) override;
+  void OnSelectionChanged(berry::IWorkbenchPart::Pointer /*source*/,
+                                    const QList<mitk::DataNode::Pointer> &nodes);
 
   Ui::QmitkPointSetInteractionViewControls* m_Controls;
 
diff --git a/SuperBuild.cmake b/SuperBuild.cmake
index b83484ef43..22d104a7d2 100644
--- a/SuperBuild.cmake
+++ b/SuperBuild.cmake
@@ -211,6 +211,22 @@ set(mitk_depends )
 
 # Include external projects
 include(CMakeExternals/MITKData.cmake)
+
+
+foreach(MITK_EXTENSION_DIR ${MITK_EXTENSION_DIRS})
+  set(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_EXTENSION_DIR}/CMakeExternals)
+  get_filename_component(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR} ABSOLUTE)
+  FILE(GLOB MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR}/*Data.cmake)
+  foreach(MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES})
+    if(EXISTS ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+        include(${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+    endif()
+  endforeach()
+endforeach()
+
+
+
+
 foreach(p ${external_projects})
   set(p_hash "")
 
